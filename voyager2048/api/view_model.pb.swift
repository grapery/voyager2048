// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: common-protoc/view_model.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Grapery_Api_LikeType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case browser // = 0

  /// orange,激进的
  case left // = 1

  /// blue，温和的
  case middle // = 2

  /// green 保守的
  case right // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .browser
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .browser
    case 1: self = .left
    case 2: self = .middle
    case 3: self = .right
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .browser: return 0
    case .left: return 1
    case .middle: return 2
    case .right: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Grapery_Api_LikeType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Grapery_Api_LikeType] = [
    .browser,
    .left,
    .middle,
    .right,
  ]
}

#endif  // swift(>=4.2)

enum Grapery_Api_GenderType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// 不公开性别
  case none // = 0
  case man // = 1
  case women // = 2
  case double // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .man
    case 2: self = .women
    case 3: self = .double
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .man: return 1
    case .women: return 2
    case .double: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Grapery_Api_GenderType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Grapery_Api_GenderType] = [
    .none,
    .man,
    .women,
    .double,
  ]
}

#endif  // swift(>=4.2)

enum Grapery_Api_UserStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case rest // = 0
  case study // = 1
  case busy // = 2
  case working // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .rest
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .rest
    case 1: self = .study
    case 2: self = .busy
    case 3: self = .working
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .rest: return 0
    case .study: return 1
    case .busy: return 2
    case .working: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Grapery_Api_UserStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Grapery_Api_UserStatus] = [
    .rest,
    .study,
    .busy,
    .working,
  ]
}

#endif  // swift(>=4.2)

enum Grapery_Api_GroupStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case notReady // = 0
  case normal // = 1
  case viewOnly // = 2
  case abandon // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .notReady
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notReady
    case 1: self = .normal
    case 2: self = .viewOnly
    case 3: self = .abandon
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .notReady: return 0
    case .normal: return 1
    case .viewOnly: return 2
    case .abandon: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Grapery_Api_GroupStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Grapery_Api_GroupStatus] = [
    .notReady,
    .normal,
    .viewOnly,
    .abandon,
  ]
}

#endif  // swift(>=4.2)

enum Grapery_Api_ActiveType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case allActive // = 0
  case like // = 1
  case share // = 2
  case comment // = 3
  case collect // = 4
  case disAgree // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .allActive
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .allActive
    case 1: self = .like
    case 2: self = .share
    case 3: self = .comment
    case 4: self = .collect
    case 5: self = .disAgree
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .allActive: return 0
    case .like: return 1
    case .share: return 2
    case .comment: return 3
    case .collect: return 4
    case .disAgree: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Grapery_Api_ActiveType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Grapery_Api_ActiveType] = [
    .allActive,
    .like,
    .share,
    .comment,
    .collect,
    .disAgree,
  ]
}

#endif  // swift(>=4.2)

enum Grapery_Api_ItemType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case allItem // = 0
  case shortWord // = 1
  case paper // = 2
  case picture // = 3
  case video // = 4
  case music // = 5
  case link // = 6
  case location // = 7
  case UNRECOGNIZED(Int)

  init() {
    self = .allItem
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .allItem
    case 1: self = .shortWord
    case 2: self = .paper
    case 3: self = .picture
    case 4: self = .video
    case 5: self = .music
    case 6: self = .link
    case 7: self = .location
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .allItem: return 0
    case .shortWord: return 1
    case .paper: return 2
    case .picture: return 3
    case .video: return 4
    case .music: return 5
    case .link: return 6
    case .location: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Grapery_Api_ItemType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Grapery_Api_ItemType] = [
    .allItem,
    .shortWord,
    .paper,
    .picture,
    .video,
    .music,
    .link,
    .location,
  ]
}

#endif  // swift(>=4.2)

enum Grapery_Api_AuthType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case notSupport // = 0
  case withPhone // = 1
  case withEmail // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .notSupport
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notSupport
    case 1: self = .withPhone
    case 2: self = .withEmail
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .notSupport: return 0
    case .withPhone: return 1
    case .withEmail: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Grapery_Api_AuthType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Grapery_Api_AuthType] = [
    .notSupport,
    .withPhone,
    .withEmail,
  ]
}

#endif  // swift(>=4.2)

enum Grapery_Api_VisibleType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case allPublic // = 0
  case `public` // = 1
  case `private` // = 2
  case someone // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .allPublic
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .allPublic
    case 1: self = .public
    case 2: self = .private
    case 3: self = .someone
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .allPublic: return 0
    case .public: return 1
    case .private: return 2
    case .someone: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Grapery_Api_VisibleType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Grapery_Api_VisibleType] = [
    .allPublic,
    .public,
    .private,
    .someone,
  ]
}

#endif  // swift(>=4.2)

struct Grapery_Api_Tags {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var groupID: UInt64 = 0

  var creatorID: UInt64 = 0

  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Grapery_Api_UserInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: UInt64 = 0

  var name: String = String()

  var avatar: String = String()

  var email: String = String()

  var location: String = String()

  /// uint64 LastActiveTime = 7;
  var desc: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Grapery_Api_GroupInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var groupID: UInt64 {
    get {return _storage._groupID}
    set {_uniqueStorage()._groupID = newValue}
  }

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var avatar: String {
    get {return _storage._avatar}
    set {_uniqueStorage()._avatar = newValue}
  }

  var desc: String {
    get {return _storage._desc}
    set {_uniqueStorage()._desc = newValue}
  }

  var creator: Grapery_Api_UserInfo {
    get {return _storage._creator ?? Grapery_Api_UserInfo()}
    set {_uniqueStorage()._creator = newValue}
  }
  /// Returns true if `creator` has been explicitly set.
  var hasCreator: Bool {return _storage._creator != nil}
  /// Clears the value of `creator`. Subsequent reads from it will return its default value.
  mutating func clearCreator() {_uniqueStorage()._creator = nil}

  var owner: Grapery_Api_UserInfo {
    get {return _storage._owner ?? Grapery_Api_UserInfo()}
    set {_uniqueStorage()._owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  var hasOwner: Bool {return _storage._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  mutating func clearOwner() {_uniqueStorage()._owner = nil}

  var tags: [Grapery_Api_Tags] {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Grapery_Api_ProjectInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var projectID: UInt64 {
    get {return _storage._projectID}
    set {_uniqueStorage()._projectID = newValue}
  }

  var groupID: UInt32 {
    get {return _storage._groupID}
    set {_uniqueStorage()._groupID = newValue}
  }

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var avatar: String {
    get {return _storage._avatar}
    set {_uniqueStorage()._avatar = newValue}
  }

  var creator: Grapery_Api_UserInfo {
    get {return _storage._creator ?? Grapery_Api_UserInfo()}
    set {_uniqueStorage()._creator = newValue}
  }
  /// Returns true if `creator` has been explicitly set.
  var hasCreator: Bool {return _storage._creator != nil}
  /// Clears the value of `creator`. Subsequent reads from it will return its default value.
  mutating func clearCreator() {_uniqueStorage()._creator = nil}

  var owner: Grapery_Api_UserInfo {
    get {return _storage._owner ?? Grapery_Api_UserInfo()}
    set {_uniqueStorage()._owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  var hasOwner: Bool {return _storage._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  mutating func clearOwner() {_uniqueStorage()._owner = nil}

  var tags: [Grapery_Api_Tags] {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  var visable: Grapery_Api_VisibleType {
    get {return _storage._visable}
    set {_uniqueStorage()._visable = newValue}
  }

  var isAchieve: Bool {
    get {return _storage._isAchieve}
    set {_uniqueStorage()._isAchieve = newValue}
  }

  var isClose: Bool {
    get {return _storage._isClose}
    set {_uniqueStorage()._isClose = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Grapery_Api_ProjectProfileInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var projectID: UInt64 = 0

  var groupID: UInt32 = 0

  var description_p: String = String()

  var watchingCount: UInt64 = 0

  var involvedCount: UInt64 = 0

  var avatar: String = String()

  var visable: Grapery_Api_VisibleType = .allPublic

  var isAchieve: Bool = false

  var isClose: Bool = false

  var isPrivate: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Grapery_Api_ActiveInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var user: Grapery_Api_UserInfo {
    get {return _storage._user ?? Grapery_Api_UserInfo()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  var activeType: Grapery_Api_ActiveType {
    get {return _storage._activeType}
    set {_uniqueStorage()._activeType = newValue}
  }

  var itemInfo: Grapery_Api_ItemInfo {
    get {return _storage._itemInfo ?? Grapery_Api_ItemInfo()}
    set {_uniqueStorage()._itemInfo = newValue}
  }
  /// Returns true if `itemInfo` has been explicitly set.
  var hasItemInfo: Bool {return _storage._itemInfo != nil}
  /// Clears the value of `itemInfo`. Subsequent reads from it will return its default value.
  mutating func clearItemInfo() {_uniqueStorage()._itemInfo = nil}

  var projectInfo: Grapery_Api_ProjectInfo {
    get {return _storage._projectInfo ?? Grapery_Api_ProjectInfo()}
    set {_uniqueStorage()._projectInfo = newValue}
  }
  /// Returns true if `projectInfo` has been explicitly set.
  var hasProjectInfo: Bool {return _storage._projectInfo != nil}
  /// Clears the value of `projectInfo`. Subsequent reads from it will return its default value.
  mutating func clearProjectInfo() {_uniqueStorage()._projectInfo = nil}

  var groupInfo: Grapery_Api_GroupInfo {
    get {return _storage._groupInfo ?? Grapery_Api_GroupInfo()}
    set {_uniqueStorage()._groupInfo = newValue}
  }
  /// Returns true if `groupInfo` has been explicitly set.
  var hasGroupInfo: Bool {return _storage._groupInfo != nil}
  /// Clears the value of `groupInfo`. Subsequent reads from it will return its default value.
  mutating func clearGroupInfo() {_uniqueStorage()._groupInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Grapery_Api_WordDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var content: String = String()

  var length: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Grapery_Api_PictureInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var resourceURL: String = String()

  var size: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Grapery_Api_PictureDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var list: [Grapery_Api_PictureInfo] = []

  var num: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Grapery_Api_VideoInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var resourceURL: String = String()

  var size: UInt64 = 0

  var timeLength: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Grapery_Api_VideoDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var list: [Grapery_Api_VideoInfo] = []

  var num: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Grapery_Api_MusicShareDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var resourceURL: String = String()

  var source: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Grapery_Api_VoiceDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var resourceURL: String = String()

  var size: UInt64 = 0

  var timeLength: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Grapery_Api_ShareDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var resourceURL: String = String()

  var source: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Grapery_Api_ItemDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var detail: Grapery_Api_ItemDetail.OneOf_Detail? = nil

  var word: Grapery_Api_WordDetail {
    get {
      if case .word(let v)? = detail {return v}
      return Grapery_Api_WordDetail()
    }
    set {detail = .word(newValue)}
  }

  var pictures: Grapery_Api_PictureDetail {
    get {
      if case .pictures(let v)? = detail {return v}
      return Grapery_Api_PictureDetail()
    }
    set {detail = .pictures(newValue)}
  }

  var video: Grapery_Api_VideoDetail {
    get {
      if case .video(let v)? = detail {return v}
      return Grapery_Api_VideoDetail()
    }
    set {detail = .video(newValue)}
  }

  var music: Grapery_Api_MusicShareDetail {
    get {
      if case .music(let v)? = detail {return v}
      return Grapery_Api_MusicShareDetail()
    }
    set {detail = .music(newValue)}
  }

  var voice: Grapery_Api_VoiceDetail {
    get {
      if case .voice(let v)? = detail {return v}
      return Grapery_Api_VoiceDetail()
    }
    set {detail = .voice(newValue)}
  }

  var share: Grapery_Api_ShareDetail {
    get {
      if case .share(let v)? = detail {return v}
      return Grapery_Api_ShareDetail()
    }
    set {detail = .share(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Detail: Equatable {
    case word(Grapery_Api_WordDetail)
    case pictures(Grapery_Api_PictureDetail)
    case video(Grapery_Api_VideoDetail)
    case music(Grapery_Api_MusicShareDetail)
    case voice(Grapery_Api_VoiceDetail)
    case share(Grapery_Api_ShareDetail)

  #if !swift(>=4.1)
    static func ==(lhs: Grapery_Api_ItemDetail.OneOf_Detail, rhs: Grapery_Api_ItemDetail.OneOf_Detail) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.word, .word): return {
        guard case .word(let l) = lhs, case .word(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pictures, .pictures): return {
        guard case .pictures(let l) = lhs, case .pictures(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.video, .video): return {
        guard case .video(let l) = lhs, case .video(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.music, .music): return {
        guard case .music(let l) = lhs, case .music(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.voice, .voice): return {
        guard case .voice(let l) = lhs, case .voice(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.share, .share): return {
        guard case .share(let l) = lhs, case .share(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Grapery_Api_ItemInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var groupID: UInt64 = 0

  var projectID: UInt64 = 0

  var userID: UInt64 = 0

  var title: String = String()

  var content: Grapery_Api_ItemDetail {
    get {return _content ?? Grapery_Api_ItemDetail()}
    set {_content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  var hasContent: Bool {return self._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  mutating func clearContent() {self._content = nil}

  var itype: Grapery_Api_ItemType = .allItem

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _content: Grapery_Api_ItemDetail? = nil
}

struct Grapery_Api_UserProfileInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Grapery_Api_GroupProfileInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "grapery.api"

extension Grapery_Api_LikeType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Browser"),
    1: .same(proto: "Left"),
    2: .same(proto: "Middle"),
    3: .same(proto: "Right"),
  ]
}

extension Grapery_Api_GenderType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "None"),
    1: .same(proto: "Man"),
    2: .same(proto: "Women"),
    3: .same(proto: "Double"),
  ]
}

extension Grapery_Api_UserStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Rest"),
    1: .same(proto: "Study"),
    2: .same(proto: "Busy"),
    3: .same(proto: "Working"),
  ]
}

extension Grapery_Api_GroupStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NotReady"),
    1: .same(proto: "Normal"),
    2: .same(proto: "ViewOnly"),
    3: .same(proto: "Abandon"),
  ]
}

extension Grapery_Api_ActiveType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AllActive"),
    1: .same(proto: "Like"),
    2: .same(proto: "Share"),
    3: .same(proto: "Comment"),
    4: .same(proto: "Collect"),
    5: .same(proto: "DisAgree"),
  ]
}

extension Grapery_Api_ItemType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AllItem"),
    1: .same(proto: "ShortWord"),
    2: .same(proto: "Paper"),
    3: .same(proto: "Picture"),
    4: .same(proto: "Video"),
    5: .same(proto: "Music"),
    6: .same(proto: "Link"),
    7: .same(proto: "Location"),
  ]
}

extension Grapery_Api_AuthType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NotSupport"),
    1: .same(proto: "WithPhone"),
    2: .same(proto: "WithEmail"),
  ]
}

extension Grapery_Api_VisibleType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AllPublic"),
    1: .same(proto: "Public"),
    2: .same(proto: "Private"),
    3: .same(proto: "Someone"),
  ]
}

extension Grapery_Api_Tags: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Tags"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .same(proto: "creatorID"),
    3: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.creatorID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularUInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.creatorID != 0 {
      try visitor.visitSingularUInt64Field(value: self.creatorID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grapery_Api_Tags, rhs: Grapery_Api_Tags) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.creatorID != rhs.creatorID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grapery_Api_UserInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "name"),
    3: .same(proto: "avatar"),
    4: .same(proto: "email"),
    5: .same(proto: "location"),
    6: .same(proto: "desc"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.avatar) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.location) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.desc) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularUInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 3)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 4)
    }
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 5)
    }
    if !self.desc.isEmpty {
      try visitor.visitSingularStringField(value: self.desc, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grapery_Api_UserInfo, rhs: Grapery_Api_UserInfo) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.avatar != rhs.avatar {return false}
    if lhs.email != rhs.email {return false}
    if lhs.location != rhs.location {return false}
    if lhs.desc != rhs.desc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grapery_Api_GroupInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .same(proto: "name"),
    3: .same(proto: "avatar"),
    4: .same(proto: "desc"),
    5: .same(proto: "creator"),
    6: .same(proto: "owner"),
    7: .same(proto: "tags"),
  ]

  fileprivate class _StorageClass {
    var _groupID: UInt64 = 0
    var _name: String = String()
    var _avatar: String = String()
    var _desc: String = String()
    var _creator: Grapery_Api_UserInfo? = nil
    var _owner: Grapery_Api_UserInfo? = nil
    var _tags: [Grapery_Api_Tags] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _groupID = source._groupID
      _name = source._name
      _avatar = source._avatar
      _desc = source._desc
      _creator = source._creator
      _owner = source._owner
      _tags = source._tags
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._groupID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._avatar) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._desc) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._creator) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._owner) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._tags) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._groupID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._groupID, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if !_storage._avatar.isEmpty {
        try visitor.visitSingularStringField(value: _storage._avatar, fieldNumber: 3)
      }
      if !_storage._desc.isEmpty {
        try visitor.visitSingularStringField(value: _storage._desc, fieldNumber: 4)
      }
      if let v = _storage._creator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._owner {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if !_storage._tags.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tags, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grapery_Api_GroupInfo, rhs: Grapery_Api_GroupInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._groupID != rhs_storage._groupID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._avatar != rhs_storage._avatar {return false}
        if _storage._desc != rhs_storage._desc {return false}
        if _storage._creator != rhs_storage._creator {return false}
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._tags != rhs_storage._tags {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grapery_Api_ProjectInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProjectInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .standard(proto: "group_id"),
    3: .same(proto: "name"),
    4: .same(proto: "avatar"),
    5: .same(proto: "creator"),
    6: .same(proto: "owner"),
    7: .same(proto: "tags"),
    8: .same(proto: "visable"),
    9: .same(proto: "isAchieve"),
    10: .same(proto: "isClose"),
  ]

  fileprivate class _StorageClass {
    var _projectID: UInt64 = 0
    var _groupID: UInt32 = 0
    var _name: String = String()
    var _avatar: String = String()
    var _creator: Grapery_Api_UserInfo? = nil
    var _owner: Grapery_Api_UserInfo? = nil
    var _tags: [Grapery_Api_Tags] = []
    var _visable: Grapery_Api_VisibleType = .allPublic
    var _isAchieve: Bool = false
    var _isClose: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _projectID = source._projectID
      _groupID = source._groupID
      _name = source._name
      _avatar = source._avatar
      _creator = source._creator
      _owner = source._owner
      _tags = source._tags
      _visable = source._visable
      _isAchieve = source._isAchieve
      _isClose = source._isClose
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._projectID) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._groupID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._avatar) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._creator) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._owner) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._tags) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._visable) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._isAchieve) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._isClose) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._projectID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._projectID, fieldNumber: 1)
      }
      if _storage._groupID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._groupID, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._avatar.isEmpty {
        try visitor.visitSingularStringField(value: _storage._avatar, fieldNumber: 4)
      }
      if let v = _storage._creator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._owner {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if !_storage._tags.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tags, fieldNumber: 7)
      }
      if _storage._visable != .allPublic {
        try visitor.visitSingularEnumField(value: _storage._visable, fieldNumber: 8)
      }
      if _storage._isAchieve != false {
        try visitor.visitSingularBoolField(value: _storage._isAchieve, fieldNumber: 9)
      }
      if _storage._isClose != false {
        try visitor.visitSingularBoolField(value: _storage._isClose, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grapery_Api_ProjectInfo, rhs: Grapery_Api_ProjectInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._projectID != rhs_storage._projectID {return false}
        if _storage._groupID != rhs_storage._groupID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._avatar != rhs_storage._avatar {return false}
        if _storage._creator != rhs_storage._creator {return false}
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._tags != rhs_storage._tags {return false}
        if _storage._visable != rhs_storage._visable {return false}
        if _storage._isAchieve != rhs_storage._isAchieve {return false}
        if _storage._isClose != rhs_storage._isClose {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grapery_Api_ProjectProfileInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProjectProfileInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .standard(proto: "group_id"),
    3: .same(proto: "Description"),
    5: .same(proto: "WatchingCount"),
    6: .same(proto: "InvolvedCount"),
    7: .same(proto: "Avatar"),
    8: .same(proto: "visable"),
    9: .same(proto: "isAchieve"),
    10: .same(proto: "isClose"),
    11: .same(proto: "isPrivate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.groupID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.watchingCount) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.involvedCount) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.avatar) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.visable) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.isAchieve) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.isClose) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.isPrivate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.projectID != 0 {
      try visitor.visitSingularUInt64Field(value: self.projectID, fieldNumber: 1)
    }
    if self.groupID != 0 {
      try visitor.visitSingularUInt32Field(value: self.groupID, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if self.watchingCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.watchingCount, fieldNumber: 5)
    }
    if self.involvedCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.involvedCount, fieldNumber: 6)
    }
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 7)
    }
    if self.visable != .allPublic {
      try visitor.visitSingularEnumField(value: self.visable, fieldNumber: 8)
    }
    if self.isAchieve != false {
      try visitor.visitSingularBoolField(value: self.isAchieve, fieldNumber: 9)
    }
    if self.isClose != false {
      try visitor.visitSingularBoolField(value: self.isClose, fieldNumber: 10)
    }
    if self.isPrivate != false {
      try visitor.visitSingularBoolField(value: self.isPrivate, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grapery_Api_ProjectProfileInfo, rhs: Grapery_Api_ProjectProfileInfo) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.watchingCount != rhs.watchingCount {return false}
    if lhs.involvedCount != rhs.involvedCount {return false}
    if lhs.avatar != rhs.avatar {return false}
    if lhs.visable != rhs.visable {return false}
    if lhs.isAchieve != rhs.isAchieve {return false}
    if lhs.isClose != rhs.isClose {return false}
    if lhs.isPrivate != rhs.isPrivate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grapery_Api_ActiveInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActiveInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "activeType"),
    3: .same(proto: "itemInfo"),
    4: .same(proto: "projectInfo"),
    5: .same(proto: "groupInfo"),
  ]

  fileprivate class _StorageClass {
    var _user: Grapery_Api_UserInfo? = nil
    var _activeType: Grapery_Api_ActiveType = .allActive
    var _itemInfo: Grapery_Api_ItemInfo? = nil
    var _projectInfo: Grapery_Api_ProjectInfo? = nil
    var _groupInfo: Grapery_Api_GroupInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _user = source._user
      _activeType = source._activeType
      _itemInfo = source._itemInfo
      _projectInfo = source._projectInfo
      _groupInfo = source._groupInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._activeType) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._itemInfo) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._projectInfo) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._groupInfo) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._activeType != .allActive {
        try visitor.visitSingularEnumField(value: _storage._activeType, fieldNumber: 2)
      }
      if let v = _storage._itemInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._projectInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._groupInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grapery_Api_ActiveInfo, rhs: Grapery_Api_ActiveInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._user != rhs_storage._user {return false}
        if _storage._activeType != rhs_storage._activeType {return false}
        if _storage._itemInfo != rhs_storage._itemInfo {return false}
        if _storage._projectInfo != rhs_storage._projectInfo {return false}
        if _storage._groupInfo != rhs_storage._groupInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grapery_Api_WordDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WordDetail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
    2: .same(proto: "length"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.length) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 1)
    }
    if self.length != 0 {
      try visitor.visitSingularUInt64Field(value: self.length, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grapery_Api_WordDetail, rhs: Grapery_Api_WordDetail) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.length != rhs.length {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grapery_Api_PictureInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PictureInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "resource_url"),
    2: .same(proto: "size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.resourceURL) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.size) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resourceURL.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceURL, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt64Field(value: self.size, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grapery_Api_PictureInfo, rhs: Grapery_Api_PictureInfo) -> Bool {
    if lhs.resourceURL != rhs.resourceURL {return false}
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grapery_Api_PictureDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PictureDetail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "list"),
    2: .same(proto: "num"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.num) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.num != 0 {
      try visitor.visitSingularUInt64Field(value: self.num, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grapery_Api_PictureDetail, rhs: Grapery_Api_PictureDetail) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.num != rhs.num {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grapery_Api_VideoInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VideoInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "resource_url"),
    2: .same(proto: "size"),
    3: .same(proto: "timeLength"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.resourceURL) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.timeLength) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resourceURL.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceURL, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt64Field(value: self.size, fieldNumber: 2)
    }
    if self.timeLength != 0 {
      try visitor.visitSingularUInt64Field(value: self.timeLength, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grapery_Api_VideoInfo, rhs: Grapery_Api_VideoInfo) -> Bool {
    if lhs.resourceURL != rhs.resourceURL {return false}
    if lhs.size != rhs.size {return false}
    if lhs.timeLength != rhs.timeLength {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grapery_Api_VideoDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VideoDetail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "list"),
    2: .same(proto: "num"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.num) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    if self.num != 0 {
      try visitor.visitSingularUInt64Field(value: self.num, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grapery_Api_VideoDetail, rhs: Grapery_Api_VideoDetail) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.num != rhs.num {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grapery_Api_MusicShareDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MusicShareDetail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resourceUrl"),
    2: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.resourceURL) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resourceURL.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceURL, fieldNumber: 1)
    }
    if self.source != 0 {
      try visitor.visitSingularUInt64Field(value: self.source, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grapery_Api_MusicShareDetail, rhs: Grapery_Api_MusicShareDetail) -> Bool {
    if lhs.resourceURL != rhs.resourceURL {return false}
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grapery_Api_VoiceDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VoiceDetail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resourceUrl"),
    2: .same(proto: "size"),
    3: .same(proto: "timeLength"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.resourceURL) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.timeLength) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resourceURL.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceURL, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt64Field(value: self.size, fieldNumber: 2)
    }
    if self.timeLength != 0 {
      try visitor.visitSingularUInt64Field(value: self.timeLength, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grapery_Api_VoiceDetail, rhs: Grapery_Api_VoiceDetail) -> Bool {
    if lhs.resourceURL != rhs.resourceURL {return false}
    if lhs.size != rhs.size {return false}
    if lhs.timeLength != rhs.timeLength {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grapery_Api_ShareDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShareDetail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resourceUrl"),
    2: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.resourceURL) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resourceURL.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceURL, fieldNumber: 1)
    }
    if self.source != 0 {
      try visitor.visitSingularUInt64Field(value: self.source, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grapery_Api_ShareDetail, rhs: Grapery_Api_ShareDetail) -> Bool {
    if lhs.resourceURL != rhs.resourceURL {return false}
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grapery_Api_ItemDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ItemDetail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "word"),
    2: .same(proto: "pictures"),
    3: .same(proto: "video"),
    4: .same(proto: "music"),
    5: .same(proto: "voice"),
    6: .same(proto: "share"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Grapery_Api_WordDetail?
        if let current = self.detail {
          try decoder.handleConflictingOneOf()
          if case .word(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.detail = .word(v)}
      }()
      case 2: try {
        var v: Grapery_Api_PictureDetail?
        if let current = self.detail {
          try decoder.handleConflictingOneOf()
          if case .pictures(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.detail = .pictures(v)}
      }()
      case 3: try {
        var v: Grapery_Api_VideoDetail?
        if let current = self.detail {
          try decoder.handleConflictingOneOf()
          if case .video(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.detail = .video(v)}
      }()
      case 4: try {
        var v: Grapery_Api_MusicShareDetail?
        if let current = self.detail {
          try decoder.handleConflictingOneOf()
          if case .music(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.detail = .music(v)}
      }()
      case 5: try {
        var v: Grapery_Api_VoiceDetail?
        if let current = self.detail {
          try decoder.handleConflictingOneOf()
          if case .voice(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.detail = .voice(v)}
      }()
      case 6: try {
        var v: Grapery_Api_ShareDetail?
        if let current = self.detail {
          try decoder.handleConflictingOneOf()
          if case .share(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.detail = .share(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.detail {
    case .word?: try {
      guard case .word(let v)? = self.detail else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .pictures?: try {
      guard case .pictures(let v)? = self.detail else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .video?: try {
      guard case .video(let v)? = self.detail else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .music?: try {
      guard case .music(let v)? = self.detail else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .voice?: try {
      guard case .voice(let v)? = self.detail else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .share?: try {
      guard case .share(let v)? = self.detail else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grapery_Api_ItemDetail, rhs: Grapery_Api_ItemDetail) -> Bool {
    if lhs.detail != rhs.detail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grapery_Api_ItemInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ItemInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "project_id"),
    3: .standard(proto: "user_id"),
    4: .same(proto: "title"),
    5: .same(proto: "content"),
    6: .same(proto: "itype"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.projectID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._content) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.itype) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularUInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if self.projectID != 0 {
      try visitor.visitSingularUInt64Field(value: self.projectID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularUInt64Field(value: self.userID, fieldNumber: 3)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 4)
    }
    if let v = self._content {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if self.itype != .allItem {
      try visitor.visitSingularEnumField(value: self.itype, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grapery_Api_ItemInfo, rhs: Grapery_Api_ItemInfo) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.projectID != rhs.projectID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.title != rhs.title {return false}
    if lhs._content != rhs._content {return false}
    if lhs.itype != rhs.itype {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grapery_Api_UserProfileInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserProfileInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grapery_Api_UserProfileInfo, rhs: Grapery_Api_UserProfileInfo) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grapery_Api_GroupProfileInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupProfileInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grapery_Api_GroupProfileInfo, rhs: Grapery_Api_GroupProfileInfo) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
